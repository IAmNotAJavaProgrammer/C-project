#include<stdio.h>

int main(){
	
} 
/*scanf的原型：
	需要一个参数能保存别的变量的地址
	指针变量：
		变量的值是内存的地址
		普通的变量的值是实际的值
		指针变量的值是具有实际值的变量的地址
			定义：指针就是保存地址的变量
				int i ;
				int* p=&i;（p指向i，值是i的地址）
				int* p，q;等价于int *p,q;
				*可以靠近p也可远离p，以上两行意思是将*加给p，而不是加给int，q只是个普通的变量
		作为参数的指针：
			void f(int *p); 
			在被调用的时候得到了某个变量的地址：
				int i=0;f(&i);
			在函数里可以通过这个指针访问外面的那个i 
		访问那个地址上的变量：
			运算符：*
				是一个单目运算符，用来访问指针的值所表示的地址上的变量
				可以做右值也可以做左值，
				通过指针可以使用，也可以更改变量 
					int k=*p;
					*p=k+1;	
						*p看做整体认为是整数 
				左值之所以叫左值，是因为出现在赋值号左边的不是变量，而是值，是表示表达式计算的结果，是特殊的值，所以叫做值	
				
		互相反作用：
			*&y就是得到地址上的变量，即y的值；&*y得到地址，即y 
		为什么scanf	("%d",i)没报错？ 在32位架构下地址大小和int大小相同		
		指针的使用：
			1、 交换两个变量的值
				void swap(int *pa,int *pb){
					int t=*pa;
					*pa=*pb;
					*pb=t;
				} 
			2、 函数返回多个值，某些值就只能通过指针返回
				传入的参数实际上是需要保存带回的结果的变量
				 	void minmax(int a[],int len,int *min,int *max){
					 	int i;
						 *min=*max=a[0];
						 for(i=1;i<len;i++){
						 	if(a[i]<*min){
							 	*min=a[i]
							 }
							if(a[i]>*max){
								*max=a[i]
							}
						 } 
					 } 这个函数通过指针返回了两个值 
			3、	函数返回运算的状态，结果通过指针返回 
				函数运算时，没有得到正确结果 ，常用套路是让函数返回特殊的不属于有效范围内的值表示出错，比如，在文件操作时0或-1 
				但是当任何数值都是有效值的可能结果时，就得分开返回 ，这时，函数的状态通过函数的返回，实际的值通过指针返回 
				 例：做除法
				 	int divide(int a,int b,int *result){
					 	int ret=1;
					 	if(b==0) ret=0;
					 	else{
							*result=a/b; 
						}
						return ret;
					 } 
					 //调用
					 if(divide(a,b,&c)){
					 	printf("%d/%d=%d",a,b,c);
					 } 
					后续的语言（C++、java）有异常机制来处理此类问题 
		常见错误：定义了变量，还没有指向任何变量，就开始使用		
