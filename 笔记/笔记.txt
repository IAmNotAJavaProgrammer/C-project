一定要注意编译器给的warning！！！

#include<stdio.h>
int main(){return 0;}
每行程序后应有“;”
“=”是赋值号
变量的定义：<变量类型> <变量名称>（变量名称不能是保留字符串）
可以在定义变量时直接进行运算
      比如：int price;
            int change=100-price;
可以在程序的任意位置定义变量（C99）在ANSI C标准下变量的定义只能在函数的开头进行
变量在第一次使用之前必须要进行一次赋值
常量：固定不变的数
    定义：const 数据类型 常量名称（C99）
    const是修饰符 加在int前给变量加上“不变”的属性
    此变量一旦初始化，就不能被修改；否则“ERROR”
 变量：能变化的量    直接量：直接写在程序里的量
 整数运算的结果只能是整数（去掉小数点后的）
 有小数点的数和无小数点的数不同
输出：printf("类型（即格式字符串）"，变量名称或表达式/"字符或字符串")（可以一次输出多个）
输入：scanf("类型"，&变量名称)（可以一次输入多个）不能处理%c
    f的意思是format 格式化的
浮点数：
      带小数点的数，“浮点”本意是指小数点是浮动的，是计算机内部表达非整数的一种方式
      另外还有定点数 即小数点是固定的（c中没有）
      浮点数表达所有有小数点的数
      浮点型变量：
            定义：double （双精度浮点型）
            float(单精度浮点型)
            scanf：%lf
            printf：%f
表达式：
    组成：运算符 例：+ - * / % = ，
          算子
    运算符优先级：单目+ - > * / % > + - > =
    只能有一个算子叫单目运算符，有两个算子叫双目运算符
    单目+-即正负号
结合关系（有相同优先级的运算符在一起的计算顺序）： 单目+ - =从右向左；+ - * / % 从左至右
    赋值是运算 有结果，即被赋的值
    嵌入式赋值：
                int a=6;
                int b;
                int c=1+(b=a);
                不利于阅读 易产生错误
程序是按顺序进行的
复合运算符：五个算术运算符可以和赋值号结合形成复合运算符
    例：total+=5 即total=total+5
        total*=sum+12 即 total=total*(sum+12)
        先算等号左边再结合
    注意：两运算符之间无空格
    ++递增运算符；--递减运算符，单目运算符，算子必须是变量，作用是给这个变量+-1
        例：count++ count+=1 count=count+1
        可以放在变量前（前缀）；也可放在变量后（后缀）
        二者作用都是增加（或减少）1，但运算结果a++=增加之前的a的值，++a=增加之后a的值
        讨论：a=b+=c++-d+--e/-f
        a=b=b+(c-d+(e-1)/-f)
scanf("%d %d")括号里加了什么在输入的时候必须加上
0:19世纪末20世纪初，有电报时O和0会弄混
条件判断if
        if(条件成){语句}果成立则执行语句，如果不成立则跳过
        条件：是一种运算，用于计算两个值之间的关系，叫做关系运算
            关系运算符（比较运算符）：==相等  !=不相等  >大于  >=大于或等于  <小于  <=小于或等于
            如果成立，结果为1，否则为0
            关系运算符的优先级低于算术运算符，高于赋值运算符；== !=低于其他关系运算符，连续的关系运算从左至右
        if(条件){语句1}else{语句2}  条件成立执行语句1，否则执行语句2
        if和else后可没有{}，此时紧跟的那一句是{}内的内容
            else总和和最近的if匹配
        级联 if{}else if{}else{} 相当于if{}else{if{}else{}}
        建议：在if和else后加上{}
            int f;              int f;
            if(x<0){            if(x<0){
                f=-1;               printf();
            }else if(x==0){     }else if(x==0){           左边代码比较好，此时是单一出口比
                    f=0;                printf();     较灵活
            }else{              }else{
                f=2*x;              printf();
            }                   }
            printf("%d",f);
        if常见错误：
                忘了{}
                if后加； 加了表明if后有语句不会执行if
                错误使用==和=
                使人感到困惑的else
        switch-case:
                    if(type==1){
                        printf(1);
                    }else if(type==2){
                        printf(2);
                    }else if(type==3){
                        printf(3);
                    }
                    else printf(4)
                    switch(type){
                        case 1:
                            printf(1);
                            break;
                        case 2:
                            printf(2);
                            break;
                        case 3:
                            printf(3);
                            break;
                        default:
                            printf(4);
                    }
                    注意！变量只能是整数,即int型
                    switch(控制表达式){
                        case 常量：
                            语句
                            ————
                        case 常量：
                            语句
                            ————
                        default ：
                            语句
                            ————
                    }

                    注意：
                        控制表达式只能是整数型的结果
                        常量可以是常量，也可以是常数计算的表达式（C99）
                        switch可以看成基于计算的跳转，计算控制表达式的值后，程序会跳到相应的case处开始执行直到遇到break若执行完相应的分支并没有遇到break，程序就会顺序执行到下一个case直到遇到break或switch结束
注释：插入在代码中，向读者提供解释信息，对程序功能没有任何影响
    类型：//单行注释  /**/多行注释
循环：
    while(条件){循环体}
        可以看做类似于if。但是，不同在于当满足条件就不断执行循环体的内容，（循环体的内容可能一次不执行）
        循环体内要有改变条件的机会，否则是死循环
通过printf输出变量的值以达到调试的目的
    do{循环体}while(循环条件);
        先执行一次再判断条件
小套路：在计算之前保存原始值，后面可能有用
    如果要模拟运行很大的循环，可以模拟较少的循环再去推断
随机数：rand() 每次召唤就随机得到一个整数
整数的分解：
    一个整数有一至多位数组成，如何分解出各个位数上的数字，并加以计算：
        1、对一个整数%10，得到个位数；
        2、做/10，去掉个位数；
        3、再对2做%10，得到原来的十位数；
        4、以此类推。
    for(初始条件;循环条件;每一轮需要做的事){}
        for(count=10;count>;count--){循环体}   对于一开始的count=10.当count>0时，重复做循环体，每一轮循环完成后，做count--.
小套路：做累加，变量初始值为0；做累乘变量初始值为1
        如果控制变量只在循环内，可以在循环内定义for(int i=1;i<=n;i++){} (C99 ONLY!)
        三个条件在一定条件下可以省略
        for(i=0;i<n;i++)循环次数是n 循环后i=n i=1 i<=n次数也是n
        for==while
        for ()中每一个条件都可省略
        有固定次数用for
        必须执行一次用do while
         其他用while
    循环控制：continue 跳出本次循环
              break跳出循环
    循环的嵌套：控制变量最好是不同的
        break 只是跳出所在的那层循环
        若想跳出多层循环：
                1、接力break 即通过修改控制变量的值使其跳出多层循环
                            for( ; ; ){
                                for( ; ; ){
                                    for( ; ; ){
                                        printf();
                                        exit=1;
                                        break;
                                    }
                                    if(exit==1){break;}
                                }
                                if(exit==1){break;}
                            }
                2、goto 标号    在需要跳到的地方写标号并加分号，可以直接跳到标号所在位置
                        有人认为这破坏了程序的结构，一般不要使用，在跳出多级循环时
pow函数：做指数运算 pow(底数，指数)
（代码复制是程序质量不良的表现）
 函数：函数是一块代码，接收零个或多个参数，做一件事，并返回零个或一个值。
    函数的定义：
        void sum(int begin,int end)//函数头  sum是函数名 void是返回类型  ()内是参数表
        {                           //大括号内是函数体
            int i;
            int sum=0;
            …………
        }
        参数表内，每一个参数之间用“，”隔开
    调用函数：函数名(参数值);
                    本来有几个就传递几个，本来是什么类型就传递什么类型
              ()起到了表示函数调用的重要作用，即使没有参数也要有()
              如果有参数则要给出正确的数量和顺序，这些值会被按照顺序一次用来初始化函数中的参数
              函数知道每一次是哪里调用它，执行完后会返回到正确的地方
    return：最好单一出口
        停止函数执行，并送回一个值
        写法：
            return;
            return 表达式;
        一个函数可以出现多个return(187行 最好单一出口！！！)
        函数可以赋值给变量，也可以再传递给函数，甚至可以丢掉
        没有返回值的函数 void
            不能使用带值的return
            可以没有return，
            调用的时候不能做函数返回值的赋值
            如果函数有返回值，则必须使用带值的return
    函数的先后顺序：
        把自己的函数写在前面是因为，C编译器是自上而下分析代码的，在使用函数前，编译器需要知道函数长什么样子（即，函数头）
        也可以将函数写在后面
            void sum(int a,int b);//函数的原型声明
            int main(){}
            voin sum(int a,int b){}//函数的定义
    函数原型：函数头以";"结尾，就构成了函数原型
        函数原型的目的是告诉编译器函数长什么样子（即，函数的名称、参数的数量及类型和返回类型）
            //旧标准习惯把函数原型写在调用它的函数里面，并将函数里所用到的变量在前面声明
        原型里可以不写参数名称，但一般都写上(编译器不会检查参数名称)
    可以传递给函数的值是表达式的结果，包括：
            字面量 变量 函数返回值 计算结果
                int a,b,c;
                a=5;
                b=6;
                c=max(10,12);
                c=max(a,b);
                c=max(c,23);
                c=max(max(23,45),a);
                c=max(23+45,b);
            如果函数参数类型不匹配，会强制转化类型(这是C语言传统上最大的漏洞，后续的C++和Java在这方面很严格)
        C在调用函数时永远只能传值给函数
        两个函数里的变量互不影

        每个函数有自己的变量空间，参数也位于这个独立空间中，和其他函数没有任何关系
        参数表里的叫“形式参数”，调用函数给的值叫“实际参数”（容易让人认为调用函数时传进函数的是变量而不是参数，而实际是相反的
    本地变量：函数的每一次运行都会形成自己的变量空间，在这个空间中的变量，是函数这次运行所    独有的，称作本地变量，也称作局部变量或自动变量
        定义在函数内部的变量都是本地变量，参数也是本地变量
    变量的生存期和作用域：
        生存期：什么时候这个变量开始出现了，到什么时候它消亡了
        作用域：在（代码的）什么范围可以访问这个变量（这个变量可以起作用）
            对于本地变量，生存期和作用域都是大括号内，叫做“块”
            本地变量规则：
                定义在函数的块内
                定义在语句的块内
                甚至可以随便拉一对{}来定义变量
                程序进入块之前，其中的变量不存在离开这个块，其中的变量就消失了
                在块外面定义的变量，在块内仍然存在
                在块内定义同名的变量，会掩盖块外的变量
                不能再一个块内定义同名变量
                本地变量不会被默认初始化
                参数在进出函数的输的时候被初始化了
    函数没有参数时:void f(void)
        void f()在传统C中，这表示函数参数表未知，并不表示没有参数
        在调用函数时()内的“,”是标点符号而不是运算符
        f(a,b)传递了两个参数   f((a,b))传递了一个参数
    C语言不允许函数嵌套定义
        可以在函数里放函数的声明，不能放函数的定义
    int i,j,sum(int a,int b);虽然C接受这样的形式，但不建议这样写
    return (i)跟return i没区别
    int main()也是一个函数，main函数是程序的入口，但在执行main之前会做别的事为程序运行做准备
        main做完后，return 有意义，它会返回给那一段程序，那段程序会将其报告给操作系统
            程序返回0说明程序运行顺利，非零则说明不顺利
    可以写成int main(void)
数组：遍历数组
    定义：类型 变量名称[元素数量]
                在此的类型准确的说是数组内元素的类型
                元素数量必须是整数
                C99以前元素数量必须是编译时刻确定的字面量！！！
                C99允许在定义数组时，下标用变量
    数组是一种容器，特点是：
                        其中所有的元素据欧相同的数据类型
                        一旦创建，不能改变大小
                        *数组中的元素在内存中是连续依次紧密排列的
        数组的每个单元就是一个int型变量
        可以出现在赋值号左边也可以出现在赋值号右边，a[2]=a[1]+6
        在赋值号左边叫做左值,在右边叫右值
        数组的每一个单元就是数组类型的变量
        使用数组时放在[]里的常数或变量叫做下表或索引，下标从0开始计数，
            这样可以简化编译器
        编译器和运行环境不会检查下标是否越界，无论是对数组单元做读还是写
        一旦程序运行，月结的数组访问可能会造成问题，导致程序崩溃 segmentation fault
        也可能运气好，没造成严重后果
        程序员右侧人来保证程序只使用有效的下标值：从0到下标值减一
        创建一个长度为0的数组 int a[0] 可以存在，但无意义
        数组要初始化！！
        使用数组时通常的环节：
                定义数组
                初始化数组
                数组参与运算
                遍历数组输出
    数组的集成初始化：
        int a[]={1,2,3,4,5,} 在初始化最后有没有“,”都一样 有逗号是古老的传统
            直接用{}给出数组的所有元素的初始值，不需要给出数组的大小，编译器可以自动给出数组的大小
        int a[13]={1} 编译器会自动初始化剩下的元素
        int a[10]={[0]=2,[2]=3,6,}; C99 ONLY!!!
            用[n]在初始化数据中给出定位
            没有定位的数据街前面的位置后面
            其他位置的值补0
            也可以不给出数组的大小让编译器算 会给出元素编号最大的那个，如，上面的例子，就是a[3]
            特别适合初始数据系数的数组
    sizeof:给出整个数组所占据的内容的大小，单位是字节 对数组求sizeof可求出数组占据多少个字节
        使用方法：sizeof(a) sizeof(a[0]) 数组的元素数：sizeof(a)/sizeof(a[0])
        这样的代码，一旦修改数组中初始数据，不需要修改遍历的代码
    数组变量之间不能赋值
    要把一个数组的所有元素交给另一个数组，必须使用遍历
        for(i=0;i<length;i++){
            b[i]=a[i];
        }
    数组遍历：通常使用for循环，让循环变量i从0到<数组长度，这样循环体内最大的i正好是数组最大的有效下标
        常见错误：
            循环条件是<=数组长度
            离开循环后继续用i的值来做数组元素的下标
    搜索数组：
        search函数：找出key在数组a中的位置
            1、key是要寻找的数字
            2、a是要寻找的数组
            3、length是数组的长度
            4、如果找到返回key在a中的位置，否则返回-1
            int search(int key,int a[],int length){
                int ret=-1;
                int i;
                for(i=0;i<length;i++){
                ret=i;
                break;
                }
                return ret;
            }
            数组作为函数参数时：
                往往必须用另一个参数来传入数组的大小
                不能再[]中给出数组的大小
                不能再利用sizeof来计算数组的元素个数
sqrt(变量名称) 计算变量的平方根 #include<math.h> 返回double类型
二维数组： int a[3][5] 三行五列
    遍历：for(i=0;i<3;i++){
            for(j=0;j<5;j++){
                a[i][j]……
            }
         }
         a[i][j]表示第i行第j列
         a[i,j]=a[j]
    初始化：int a[][5]{
                {0,1,2,3,4}，
                {2,3,4,5,6}，
            }
            列数必须给出，行数可以用编译器来数
            每行一个{}，逗号分隔
                可以不带{}从左上到右下填满
            最后逗号可以存在
            如果省略元素，自动补零
            可以定位初始化（C99 ONLY!!!）
    关于二维数组的算法：
        检查行：for(i=0;i<size&&reault==-1;i++)
数据类型：
    变量在使用前必须定义，并确定类型
    C以后的语言两个方向：
        C++/JAVA更强调类型，对类型检查更严格
        JS、PY、PHP不看重类型，甚至不需要事先定义
    早期语言强调类型，面向底层语言强调类型
    C需要类型，但对类型的安全检查不够
    类型：（括号内C99 ONLY!!!）
        整数
            char、short、int、long、(long long)
        浮点数
            float、double、(long double)
        逻辑
            (bool)
        指针
        自定义类型
        分四大类，把逻辑归到整数
        除自定义类型称为基础类型
    不同：
        类型名称
        输出的格式化类型
        所表达的数的范围：char<short<int<float<double
        内存中所占据的大小：1到16字节
        内存中表达形式：二进制数（补码）、编码
            像整数等在计算机中是二进制数或二进制的补码，而浮点型在计算机中是编码，不能直接用来计算
    sizeof()给出某个类型或变量在内存中所占据的字节数
        是静态运算符，它的结果在编译时就决定了
        不要再sizeof里做运算，这些运算不会做
        数据的大小就是-2^(n-1)~2^(n-1)-1
            n是数据的大小，即，n bit
        char：1字节  -128-127 正负数不相等是因为中间还有一个零
        short：2字节 -32768-32767
        int：取决于编译器(CPU),通常意义是“一个字” -2^(32-1)~2^(32-1)-1
        long：取决于编译器(CPU),通常意义是“一个字”
        long long：8字节
        字长：CPU寄存器宽度
            一次可以处理的数据叫一个字长
        int 就是用来表达寄存器的大小
    整数在计算机内部的表达：
        计算机内部一切都是二进制
        18 ——>00010010 0 ——>00000000
        二进制负数
            一个字节可以表达的数：
                00000000——11111111(0-255)
            三种方案：
                1、仿照十进制，有一个特殊的标志表示 2、这个标志在这个数以外
                取中间的数为0，比它小的是负，比它大是正
                3、补码
                    如何做到-1+1=0？
                        0——>00000000 1——>00000001
                        11111111+00000001——>100000000
                        1是多出来的一位，被丢掉
                        因为0-1——>-1，所以-1=(1)00000000-00000001——>11111111
                        11111111被当做纯二进制时是255，被看做补码时是-1
                        同理，对于-a，其补码就是0-a，实际就是2^n-a，n是这种类型的位数
                        补码的意义就是拿补码和原码可以加出一个溢出的0
                        11111111如果看作二进制就是255，如果看作是一个字节的整数的话就是-1
                        也就是说11111111在计算机内部就是255，如果拿出来就是-1
    数的范围：00000000-11111111
        其中00000000——>0
            11111111~10000000(这里是由大到小)——>-1--128(补码)
            00000001~01111111——>1-127
    unsigned:数据没有负数部分，此时对于一个字节的数据11111111就是255，而不是-1，数据的整数部分就大了
        将一个字面量表示为unsigned，在数据后加u或U(用l或L表示long)
        设计的初衷：
            为了做纯二进制的运算，主要是为了移位
    整数的越界：
        整数的运算是以纯二进制方式进行计算的
        -128|127               →
          ↑   ↓               ↑  ↓
          -1|0               255|0
    整数的输入输出
        输入输出时只有int 和long long
        %d：int  %u：unsigned
        %ld：long long  %lu：unsigned long long
        数据是什么样的，关键在于怎么看它
        一个以0开始的数字字面量是八进制
        一个以0x开始的数字字面量是十六进制
            printf("i=%x",i)x的大小写会决定输出的字母的大小写

            输出时都只会输出数字部分而不会输出“0”或“0x”
            八进制和十六进制只是如何把数字表达为字符串，与内部如何表达数字无关
            十六进制很适合表达二进制数据，四位二进制正好是以为十六进制
            八进制一位数正好表达三位二进制数
            以为早期计算机的字长是12的倍数，而非8
    选择整数类型：
        为什么整数有那么多类型？
            为了准确表达内存，做底层程序需要
        没有特殊需要就用int
        现在CPU字长普遍是32bit或64bit，一次内存读写就是一个int，一次计算也是int，选择短类型不会更快们甚至更慢
        现代编译器一般会设计内存对齐，所以更短的类型实际在内存中也占据一个int(虽然sizeof说更小)
        unsigned只是输出(位运算时)不同，内部计算时一样的
    浮点类型：
        类型    字长                    范围                       有效数字  scanf printf
        float    32       ±[1.20*10^(-38)~3.40*10^38],0，±inf，nan     7       %f   %f、%e
        double   64       ±[2.2*10^(-308)~1.79*10^308],0,±inf，nan     15      %lf %lf、%e
            ±inf(无穷大)，nan(无效数字)
            在接近0时是无法表达的
        科学计数法：可有+-，可用e或E，小数点可选，不能有空格，e后可有+-
        可以用科学计数法赋值
        输出精度：
            在%后加上.n可以控制输出小数点后几位，遵守四舍五入(小于等于5舍去，大于五进位)
            浮点数是有误差的，也就是说无法准确表达这个数，浮点数只能表达离散的数.能表达的最近的两位数之间的数无法表达，这时取离这个数最近的能表达的数来表达这个数 double两数之间的距离比float小，即，更准确
    字符类型：
        char是一种整数，也是一种特殊的类型——字符。
        用单引号表示的字符的字面量
        格式控制符%c
        混合输入：scanf("%d %c",&a,&b)最好加空格
        大小写转换：
            字母在ASCII码表中是顺序排列
            大写字母和小写字母是分开的，并不在一起
            'a'-'A'可以得到两段之间的距离
            a+'a'-'A'可以吧大写字母变成小写字母
            a+'A'-'a'可以吧一个小写字母变成大写字母
        逃逸字符：用来表达无法打印出来的控制字符或特殊字符，它由一个“\”开头，后面跟上另一个字符，这两个字符组合起来，组成了一个字符
        不同的shell会对控制字符有不同的处理
            \b回退一格，回退但不删除，如果之后还有字符就在这个位置上输出
            \t跳到下一个制表位
            \n换行 实质是回车加换行
            |r回车 回到本行的最左边，之后的输出从最左边开始替换
        自动类型转换：当运算符的两边出现不一致的类型时，会自动转换成较大的类型，即转换成能    表达的数的范围更大的类型
            char-->short-->int-->long-->long long
            int-->float-->double
            对于printf，任何小于int的类型会被转换成int，float会被转换成double
            但scanf不会，要输入short就需要%hd
        强制类型转换：
            要把一个类型的值转换成另一个类型(通常是较小的类型)，需要：
                (类型)值
                    例：(int)10.2-->10
                        (short)32
            注意这时的安全性，小的量不总是能表达大的量
            只是从那个变量计算出了一个新的类型的值，并不改变那个变量，无论是值还是类型都不改变

            强制类型转换优先级高于四则运算
    F、U、L可以放在数字字面量后表示类型
    逻辑类型：bool(C99)
        需要 #include<stdool.h>
        格式控制符：%d
运算：
    关系运算
    四则运算
    赋值运算
    逻辑运算：
        逻辑预算是对逻辑量进行运算，结果只有0或1
        逻辑量是关系运算或逻辑运算的结果
        运算符  描述
           !   逻辑非
           &&  逻辑和
           ||  逻辑或
           优先级从上到下依次减小
            单目运算符优先级大于双目运算符
    优先级   运算符         结合性
      1        ()           从左到右
      2    ! 单目+- ++ --   从右到左
      3     * / %           从左到右
      4     + -             从左到右
      5    < <= > >=        从左到右
      6   == !=             从左到右
      7     &&              从左到右
      8     ||              从左到右
      9   赋值运算符        从右到左
        短路：逻辑运算是自左至右进行的，如果左边的结果已经能够决定结果了，就不会做右边的计算
            即，对于&&，左边是FALSE时就不做右边；对于||，左边是TRUE时就不做右边
            所以，不要把赋值、符合赋值组合进表达式
    条件运算符：? :
        优先级比赋值高，比其他运算符都小
        结合性自右向左
        不希望使用嵌套条件表达式
    逗号运算符：用来连接两个表达式，，运算结果是最后一个表达式的值，优先级最小
        可以在for中使用：for(表达式,表达式;关系表达式 ;表达式,表达式,)
指针：
    scanf里的&：获得变量的地址，它的操作数必须是变量，如果不是变量就不能取地址
        相邻变量的地址相差十进制的4，地址相邻，先写的变量在上，后写的在下，先写的地址值大
        在32位架构下，地址4个字节，而在64位下，地址是8个字节。所以，地址是否与int相同取决于编译器
        数组的地址：
            相邻数组单元的地址值相差4
    scanf的原型：
        需要一个参数能保存别的变量的地址
    指针变量：
        变量的值是内存的地址
        普通的变量的值是实际的值
        指针变量的值是具有实际值的变量的地址
            定义：指针就是保存地址的变量
                  任何指针定义出来尽量初始化为NULL
                int i ;
                int* p=&i;（p指向i，值是i的地址）
                int* p，q;等价于int *p,q;
                *可以靠近p也可远离p，以上两行意思是将*加给p，而不是加给int，q只是个普通的变量
        作为参数的指针：
            void f(int *p);
            在被调用的时候得到了某个变量的地址：
                int i=0;f(&i);
            在函数里可以通过这个指针访问外面的那个i
        访问那个地址上的变量：
            运算符：*
                是一个单目运算符，用来访问指针的值所表示的地址上的变量
                可以做右值也可以做左值，
                通过指针可以使用，也可以更改变量
                    int k=*p;
                    *p=k+1;
                        *p看做整体认为是整数
                左值之所以叫左值，是因为出现在赋值号左边的不是变量，而是值，是表示表达式计算的结果，是特殊的值，所以叫做值

        互相反作用：
            *&y就是得到地址上的变量，即y的值；&*y得到地址，即y
        为什么scanf    ("%d",i)没报错？ 在32位架构下地址大小和int大小相同
        指针的使用：
            1、 交换两个变量的值
                void swap(int *pa,int *pb){
                    int t=*pa;
                    *pa=*pb;
                    *pb=t;
                }
            2、 函数返回多个值，某些值就只能通过指针返回
                传入的参数实际上是需要保存带回的结果的变量
                    void minmax(int a[],int len,int *min,int *max){
                        int i;
                         *min=*max=a[0];
                         for(i=1;i<len;i++){
                            if(a[i]<*min){
                                *min=a[i]
                             }
                            if(a[i]>*max){
                                *max=a[i]
                            }
                         }
                     } 这个函数通过指针返回了两个值
            3、  函数返回运算的状态，结果通过指针返回
                函数运算时，没有得到正确结果 ，常用套路是让函数返回特殊的不属于有效范围内的值表示出错，比如，在文件操作时0或-1
                但是当任何数值都是有效值的可能结果时，就得分开返回 ，这时，函数的状态通过函数的返回，实际的值通过指针返回
                 例：做除法
                    int divide(int a,int b,int *result){
                        int ret=1;
                        if(b==0) ret=0;
                        else{
                            *result=a/b;
                        }
                        return ret;
                     }
                     //调用
                     if(divide(a,b,&c)){
                        printf("%d/%d=%d",a,b,c);
                     }
                    后续的语言（C++、java）有异常机制来处理此类问题
        常见错误：
            定义了变量，还没有指向任何变量，就开始使用，这时p可能指向一个未知的地址，对*p做赋值的话会改变那个地址里的值，从而导致程序出错
    指针与数组：
        函数参数表里的数组实际上是指针，但可以用数组的运算符[]进行运算，
        在函数里，sizeof(a)==sizeof(int *)
        函数参数表里的数组[]里不能带元素个数，在函数里不能用sizeof求出数组的大小，在函数里对数组做的赋值会影响到函数外
        void minmax(int a[],int len)可以这样写：
            void minmax(int *a,int len)
        以下四种函数原型是等价的：
            int sum(int *ar,int n);
            int sum(int *,int );
            int sum(int ar[],int n);
            int sum(int [],int );
        数组变量是特殊的指针
            数组变量本身表达地址，所以取变量的地址的时候不需要用&，
                int a[10];int *p=a
            但是数组的单元表达的是变量，需要用&取地址
            a==&a[0]
            []运算符可以对数组做，也可以对指针做
                p[0]<==>a[0]若所指的变量不是数组，那么就把这个变量看做有一个元素的数组取地址
            数组变量是const的指针，即常量指针，所以不能被赋值(两数组间不能赋值)
                int a[]<==>int *const a
    指针与const（C99 ONLY!!!）：

    指针运算：
        1、+或-一个整数
        2、递增、递减（++/--）
        3、两个指针相减
            结果是两个地址值相减除以sizeof(类型)，即两个指针所指向的变量之间相差几个此类型的元素
        指针+1实际是在原来的指针上加一个sizeof(类型)
            比如，如果指针指向一个变量，
            那么指针+1指的是指针指向下一个单元
                char ac[]={1,2,};
                char *p=ac;
                此时，p指向ac[0],p+1指向ac[1]，即，*(p+n)<==>ac[n]
            地址值+1没有意义
            如果指针不是指向一片连续分配的空间（如，数组），这种运算没有意义
        4、*p++
            取出p所指的那个数据，之后便把p移到下个位置（注：p++的结果是p）
            ++的优先级比*高
            常用于数组类的连续空间操作，比如，遍历
                while(*p!=-1){  //(-1是无效数据)
                    printf("%d\n",*p++);
                }
                等价于：//ac是数组
                    for(p=ac;*p!=-1;p++){
                        printf("%d\n",*p);
                    }
            在某些CPU上，这可以直接被翻译成一条汇编指令
        5、指针比较
            <,>,<=,>=,!=
            比较在内存中的地址
            数组中的单元地址肯定是线性递增排列的
    0地址：任何程序里都有0地址，0地址通常是不能碰的
        所以指针不该具有0值
        可以用0地址做一些特殊的事：
            表示返回的指针是无效的
            初始化指针为0，此时指针没有被真正地初始化，此时如果调用该指针，系统会崩溃
        NULL是一个预定定义的符号，表示0地址
        有的编译器，不愿意用0表示0地址
        需要用0地址，尽量用NULL
    无论指向什么类型，所有的指针的大小都是一样的，因为都是指针
    为了避免用错指针，指向不同类型的指针是不能直接互相赋值的
        例：char ac[]{0,1,2,3,4,5,6};
            int ai[]{0,1};
            char *p;
            int *q;
            q=p;
            此时因为数据类型大小不一样
            会使p[0]~p[3]都等于0
    指针的类型转换：
        void *p;表示不知道指向什么类型的指针
            表示用一个指针表达内存中的某块内存空间。往往用在底层程序
        int *p=&i;void *q=(void*)p；
        这并没有改变p所指的变量的类型，而只是认为i不是int，而是void
    指针与const：
        const int *p=&i;表示不能通过这个指针去修改那个变量
        int *const p=&i;表示一旦得到了某个变量的地址，不能再指向其他的变量
    指针能做什么：
        需要传入较大的数据时做参数
        传入数组后对数组做操作
        函数返回不止一个结果时用指针返回
        需要用函数来修改不止一个变量时
        动态申请内存
    函数指针：
        定义：void (*pf)(参数表)=f
        使用：(*pf)()
        实例：
            1)  int i=0;
                void(*fa[])(int)={f,g,h};
                scanf("%d",i);
                if(i>=0&&i<sizeof(fa)/sizeof(fa[0])){
                    (*fa[i])(0);
                }
            2)  用函数调用函数
动态内存分配：
    输入数据：如果输入数据时先告诉你个数，然后再输入，要记录每个数据，C99可以用变量做数组的定义，在C99之前：
        int *a=(int*)malloc(n*sizeof(int));
            malloc函数：
                向系统申请空间，以字节为单位
                #include <stdlib.h>
                void* malloc()
                malloc返回void*

                如果申请失败则返回0或NULL
                空间用完后需要free(a)
                    把申请来的空间还给系统
                    只能还申请过来的空间的首地址
                常见问题：
                    申请了没free
                    free过了再free
                    地址变过了，直接去free
字符串：
    以0结尾的一串字符
    0或\0是一样的，但和'0'不一样
    0标志字符串的结束，但不是字符串的一部分
    计算字符串长度时不包括这个0
    字符串以数组的形式存在，以数组或指针的形式访问，更多的是以指针的形式
    string.h里有很多处理字符串的函数
    字符数组：char word[]={'H','e','l','l','o','!'};
    C语言字符串：char word[]={'H','e','l','l','o','!','\0'};
        可以使用字符串计算
    字符串变量：
        char *str="hello";
        char word[]="hello";
        char line[10]="hello";
        编译器会自动补\0，也就是说以上变量实际大小是6个字节
        由""括起来的东西叫字符串的字面量或字符串的常量
        "hello"会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0
        两个相邻的字符串常量，会被连接起来
            printf("请分别输入身高的"
                "英尺和英寸：");
        不能用运算符对字符串做运算
        通过数组的方式可以便利字符串
        字符串字面量可以用来初始化字符数组
        C的标准库提供了一些字符串函数

        char *s="Hello World!";
        char *s2="Hello World!";//此时s、s2指向相同的地方
        s[0]='B';
        printf("s[0]=%c\n",s[0]);
            此时程序运行错误，此时，"Hello World!"放在程序代码段，是只读的，若试图对其修改，系统会让程序崩溃
            s实际是const char *s，但由于历史的原因，编译器接受不带const的写法
            如果需要修改,要用数组：
                char s[]="Hello World!"
            是选择指针还是数组
                数组：这个字符串就在这，作为本地变量，内存空间会被自动回收
                指针：这个字符串不知道在哪
                    处理参数
                    动态分配空间时
                如果需要构造一个字符串用数组，如果呀处理一个字符串用指针
            字符串可以表达为char*的形式，但不一定是字符串
            本意是指向字符的指针，可能指向的是字符的数组(就像int*一样)
            只有它所指的字符数组结尾有0，才能说它所指的是字符串

    字符串的赋值：
        char *t="tittle";
        char *s;
        s=t; //令s指向t所指的字符串
    字符串的输入和输出：
        格式控制符：%s
        char word[8];
        scanf("%s",word);
        printf("%s\n",word);

            scanf("%s",word);//读入一个单词，直到空格、TAB或回车为止，但scanf是不安全的，因为不知道要读入的内容的长度
            scanf("%7s",word);%和s之间的数字表示最多允许读入的字符数量，这个数字应该比数组的大小小一，下一次的scanf将会从超出长度的地方开始
        常见错误：
            char *string;
            scanf("%s",string);
                误以为char*是字符串类型
                由于没有对string做初始化，运行时可能出错，也可能不出错
        空字符串：
            char buffer[100]="";
            这一个空字符串，buffer='\0'
            char buffer[]="";//这个数组长度只有1
    单字符输入输出：
        putchar函数：
            int putchar(int c);//参数不是char类型而是int类型，但还是只能接收一个char
            向标准输出写一个字符
            返回值也是int 返回值表示写了几个字符，返回EOF(-1)（EOF是一个宏值是-1，即返回-1）表示写失败
        getchar函数：
            int getchar(void);
            从标准输入读入一个字符
            返回值是EOF(-1),表示输入结束
            在键盘上输入的所有的内容，都是先放在shell的缓冲区，然后程序根据需要到shell的缓冲区提取数据
            令标准输入结束：即让shell在缓冲区生成输入结束指令，getchar读到后结束输入
                widows——>Ctrl+Z
                Unix——>Ctrl+D
    字符处理函数：#include <string.h>
        strlen: 返回s的字符串长度（不包括0）
            size_t strlen(const char *s)//const的意思是本函数不会修改字符串的内容
            示例：
                char line[]="Hello";
                strlen(line);
            size_t mystr(const *s){
                int cnt=0;
                while(s[cnt]!='\0'){
                    cnt++;
                }
                return cnt;
            }
        strcmp：比较两个字符串，返回0（s1==s2）、1（s1>s2）、-1（s1<s2）
            若不相等，有的编译器会使s1-s2
            int mycmp(const *s1,const char *s2){
                int idx=0;
                while(s1[idx]==s2[idx]&&(s1[idx]!='\0'){
                    idx++;
                }
                return s1[idx]-s2[idx];
                //另一种写法
                while (*s1==*s2&&*s1!'\0'){
                    s1++;
                    s2++;
                }
                return *s1-*s2;
                //另一种写法
            }
            char *strncmp(const char *s1,const char *s2,size_t n);
        strcpy:把src的字符串复制到dst
            char *strcpy(char *restrict dst,char *restrict scr)
            restrict表明src和dst不能重叠（C99）
            返回dst，为了strcpy能参与其他计算(链接其他代码)
            应用：
                char *dst=(char*)malloc(strlen(src)+1);
                strcpy(dst,src);
            简单的代码：
            char *mycpy(char *restrict dst,char *restrict scr){
                while (src[idx]!='\0'){
                    dst[idx]=src[idx];
                    idx++;
                }
                dst[idx]='\0';
                return dst;
                //指针版本
                char *ret=dst;
                while(*src!='\0'){
                    *dst++=*srx++;
                }
                *dst='\0';
                return ret;
                //另一指针版本
                while(*dst++=*src++);
                *dst='\0';
                return ret;
            }
            可能出现安全问题
        strcat:把s2拷贝到s1的后面，接成一个长的字符串并返回s1(从\0开始，即从s1[strlen(s1)]=s2[0])，s1必须有足够的空间
            char *strcat(cahr *restrict s1,const char *restrict s2);
            可能出现安全问题
        strchr：在字符串中找字符
            char *strchr(const char *s,int c);找到字符第一次出现的位置，返回的是指向第一个字符的指针
                char s[]="Hello"
                char *p=strchr(s,'l');

            strrchr：从右往左找
                返回NULL表示没有找到
            应用：
                如何寻找第二个字符？
                    char s[]="Hello"
                    char *p=strchr(s,'l');
                    p=strchr(p+1,'l');
                将第一个字符及之后的字符复制到另一个变量
                    char s[]="Hello"
                    char *p=strchr(s,'l');
                    char *t=(char*malloc(strlen(p)+1));
                    strcpy(t,p);
                获得字符之前的字符
                    char s[]="Hello"
                    char *p=strchr(s,'l');
                    char c=*p;
                    *p="\0";
                    char *t=(char*)malloc(strlen(s)+1);
                    strcpy(t,p);
                    *p=c;
        strstr:在字符串中找字符串
            char *strstr(const char *s1.const char *s2);
            char *strcasestr(const char *s1,const char *s2);//忽略大小写寻找

        strcpy和strcat的安全版本：
            char *strncpy(char *restrict dst,const char *restrict src,size_t n);
            char *strncat(char *restrict s1,const char *restrict s2,size_t n);
结构类型：
    枚举：是一种用户定义的数据类型
        enum 枚举类型名字{名字0,名字1,……,名字n}
        使用：enum 名字 变量名
        枚举类型名字通常并不是真的使用，要用的是在大括号里的名字，因为它们就是符号常量，类型是int，值依次从0到n
        当需要一些可以排列起来的常量值时，定义枚举的意义就是给这些长亮值名字
        枚举量可以作为值，
        枚举类型可一个上enum作为类型
        实际上是以整数来做内部计算和外部输入的
        由于枚举量是从0依次递增的，所以可以将最后一个元素定为numof来统计元素个数，这样就可以用来遍历或建立数组
        声明枚举量时可以指定值
            enum COLOR{RED=1，YELLOW,GREEN=5};//此时YELLOW=2
        即使给枚举类型的变量赋不存在的整数值也没有任何warning或error
        虽然枚举类型可以当做类型用，但实际上很少用、不好用
        有时枚举比const int好用
        枚举比宏好用，因为枚举有int类型
    结构：
        声明：
            struct 名字{ 数据类型0 名字0;数据类型1 名字1……};
            struct 名字 变量;
            struct{数据类型0 名字0;数据类型1 名字1……}变量;
            这是无名结构
            struct 名字{ 数据类型0 名字0;数据类型1 名字1……}变量;
            结构类型和结构变量不同
            结构的初始化：
                struct date today={07,31,2014};
                struct thismonth ={,month=07,year=2014};
                没有赋值的填0
            在函数内外都可以，生存周期不同
            结构成员：
                用“.”运算符和名字访问其成员
                    结构变量.成员名字
                    例：today.day
            可以拿结构整体做运算，可以做赋值、取地址，也可以传递给函数
                比如：
                    p1=(struct point){5,10};
                    p1=p2
            和数组不同，结构变量的名字并不是结构变量的地址，必须用&取地址
            .结构比&高
    结构与函数：
        int num(struct date d)
        整个结构可以作为参数传入函数，传入函数的只是结构的值，也就是说函数外的结构值不受函数影响
            解决方案：
                创建一个临时的结构变量并返回，在函数外赋值给结构变量

                结构指针作为参数
                    struct point *grtstruct(struct point *p)

        这是在函数内新建一个结构变量，并赋值调用者的结构的值
        也可以返回一个结构
        没有直接的方式一次scanf结构的所有值
    指向结构的指针:
        struct date *p=&myday
        访问结构中的成员：
            (*p).month=12;
            p->month=12;
    结构数组：
        struct date dates[100];
        struct date dates[]={{4.5.2005},{2.4.2005}}
    结构中的结构：
        可以在结构类型声明中声明结构类型
        也可以在结构类型声明中定义结构变量
            struct point {
                int x;
                int y;
            };
            struct rect{
                struct point pt1;
                struct point pt2;
            }
            如果有变量struct rect r;
            就可以 r.ptr.x、r.pt1.y
            如果有变量定义
            struct rectangle r,*rp
            rp=&r;
            那么下面的四种形式是等价的：
            r.ptl.x
            rp->ptl.x
            (r.ptl).x
            (rp->ptl).x
            但是没有rp->ptl->x(因为prl不是指针）
            如果我们在C语言中定义了一个结构体，然后申明一个指针指向这个结构体，那么我们要用指针取出结构体中的数据，就要用到“->”.
类型定义：
        typedef：声明已有数据类型的新名字
            例：typedef int Length
                Length成为了int的别名，可以代替int出现在变量定义和参数声明
            应用：
                typedef struct ADate{
                    int monthl
                    int day;
                    int year;
                } Date;//用Date代替结构类型
联合：
    union 和struct类似，声明定义相同
    存储：
        所有的成员共享一个空间
        同一时间只有一个成员有效
        union的大小是其最大的成员
    初始化：
        对第一个成员做初始化
全局变量：
    变量定义在函数外是全局变量，生存期和作用域是全局的
    初始化：没有初始化自动补零，指针会得到NULL
        只能用编译时刻已知的值初始化
        如果函数内部由于全局变量同名的变量，则全局变量被隐藏
    不要使用全局变量来在函数间传递参数和结果
    尽量避免使用全局变量
    （使用全局变量和静态本地变量的函数是线程不安全的）
静态本地变量：
    static 加上后在离开函数后本地变量还存在，下一次进去后值是上次离开时的值
        static int i=1;
        i++;
        下次进入时i是2
    静态本地变量实际上是特殊的全局变量
    位于相同的内存区域
    static在这里的意思是局部作用域
    静态本地变量具有全局的生存期和函数内的局部作用域
返回指针的函数：
    返回本地变量的地址是有危险的
    返回全局变量或静态本地变量是安全的
    返回在函数内malloc的内存是安全的，但容易造成问题
    最好的做法就是返回传入的指针
预处理指令不是C语言的代码
宏：
    d定义：
        #define 名字 值//编译器做的是文本替换
        如果宏的值中还有其他宏的名字，也会被替换
        如果宏的值超过一行，最后一行之前行的行末加\
        宏后面出现的注释不会被当做宏的值的一部分
        可以定义没有值的宏
    预定义的宏：_line_等
    带参数的宏：
        #define cube(x) ((x)*(x)*(x))
        cube(5);//相当于5*5*5
        错误的定义：
            #define cube(x) ((x)*123)√
            #define cube(x) (x*123)×
            注意优先级！！！（x可能被替换成表达式）
            一切都要有()
                整个值都要有()
                参数出现的每个地方都要有()
        可以有多个参数
        也可以嵌套
        定义的最后最后不要加分号
        部分宏会被inline替换
大程序结构：
    多个.c文件：
        新建项目
    头文件：
    存储函数原型
    只能用来声明
    include不是用来引入库
    变量的声明： extern int i;
    不能重复声明
文件：
    格式化输入输出：
        格式化字符串：
        printf：
        %[flag][width][.prec][hlL]type
            flag   含义
              -   左对齐
              +   在数据前放+或-
            space  正数留空
              0    0填充（在前面填，左对齐的话不行）

              whidth      含义
              number    最小字符数
                *       对应的参数是字符数

              .prec        含义
             .number     小数点后的位数
              .*        参数是小数点后的位数

              hlL      含义
              hh     单个字节（如果是int 12345，转变成十六进制取最低位）
               h      short
               l      long
               ll    long long
               L     long double

               type：
                    int number;
                    printf("123456%n",&number);
                        将输出的字符的个数填到number
        scanf:%[flag]type

            flag   含义
             *     跳过
             数字  最大字符数
             hh    char
             h     short
             l     long double
             ll    long long
             L     long double

             type     含义
              i     整数，八进制或十六进制或十进制
              [^,]  读到,
        printf返回值：输出的字符数
        scanf返回值：读入的字符数
        在要求严格的程序中，应该判断每次调用scanf或printf的返回值，从而了解程序运行中是否存在问题
    文件输入输出：
        重定向：
            <指定输入的文件 >指定输出的文件
            打开文件的标准代码：
                FILE *fp=fopen("file","r");
                if(fp){
                    fscanf(fp,格式控制符,指针);
                    fclose(fp);
                }else{……}
                fopen第二个参数：
                r    打开只读
                r+   打开读写，从文件头开始
                w    打开只写，如果不存在则新建，如果存在则清空
                w+   打开读写，如果不存在则新建，如果存在则清空
                a    打开追加，不存在则新建，存在则从文件尾开始
                x    只新建，如果文件已存在则不能打开
    二进制文件：
    fread(读或写的内存,内存大小,几个内存,文件指针)
    fwrite
    fseek(文件指针, ,位置) 将读写的位置移到相应位置
        SEEK_SET:从开头开始
        SEEK_CUR:从当前位置开始
        SEEK_END:从末尾开始
    ftell(文件指针)得到位置
可变数组：c项目/可变数组
链表：
    定义：
        typedef struct _node{
            int value;
            struct _node *next;
        } Node;
    实例：
        可变数组：
            int main (){
                Node *head=NULL;
                int number;
                do{
                    scanf("%d",&number);
                    if(number!=-1){
                        //add to linkedlist
                        Node *p=(Node*)malloc(sizeof(Node));
                        p->value=number;
                        p->next=NULL;
                        //find the last
                        Node* last=head;
                        if(last){
                            while(last->next){
                                last=last->next;
                            }
                            //attch
                            last->next=p;
                        }else{
                            head=p;
                        }
                    }
                }while(number!=-1);
            }
        链表函数：
            typedef struct _list{
                Node* head;
            }List;
            int main (){
                int number;
                List list;
                list.head=NULL;
                do{
                    scanf("%d",&number);
                    if(number!=-1){
                       add(&list,number)
                    }
                }while(number!=-1);
            }
            void add(List* plist,int number){
                //add to linkedlist
                Node *p=(Node*)malloc(sizeof(Node));
                p->value=number;
                p->next=NULL;
                //find the last
                Node* last=plist->head;
                if(last){
                    while(last->next){
                        last=last->next;
                    }
                    //attch
                    last->next=p;
                }else{
                    plist->head=p;
                }
            }
        链表的遍历：
            Node* p;
            for(p=list.head;p;p=p->next){}
        链表的搜索：
            searchl(List* plist,int number){
                Node* p;
                for(p=list->head;p;p=p->next){
                    if(p->value==number){
                        return 1;
                    }
                }
            }
        链表的删除：
            Node* q;
            for(q=NULL,p=list.head;p;p=p->next){
                if(p->value==number){
                    if(q){

                        q->next=p->next;
                    }else{
                        list.head=p->next;
                    }
                    free(p);
                    break;
                }
            }
        链表的清除：
            for(p=list.head;p;p=q){
                q=p->next;
                free(p);
            }
游戏设计思路：
    MVC：
        Model：存储数据
        View：读数据，给用户显示
        Control：告诉Model数据该怎么改